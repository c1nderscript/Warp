# Surrentumlabs Documentation Homepage

<!-- 
AUTOGENERATED SECTIONS WARNING:
This document contains autogenerated sections that leverage DataviewJS queries.
The sections marked with "DataviewJS Query" are dynamic and update based on:
- .scripts/cache/docs_index.json (documentation inventory cache)
- surrentumlabs_repo_inventory.json (repository inventory)

These sections are governed by rules:
- Rule dqDrwrElzQfaQ6lVR1ZtY2: Follow the rules of every AGENTS.md file in every directory you are working on as your prime directive. If AGENTS drift from the repo, modify the AGENTS
- Rule zb1YgK1oGzQCJ7qBVsLYBy: Always leave code annotations anytime you modify, edit, or move code

DataviewJS queries are powered by the inventory scripts at .scripts/inventory_docs.js and related tooling.
For updates to the documentation index, run the inventory script to regenerate the cache.
-->

## Overview

This is the central documentation homepage for all Surrentumlabs repositories. It provides interactive views of documentation files across all projects, powered by automated inventory scripts and Obsidian DataviewJS queries.

## Quick Navigation Dashboard

<!-- DataviewJS Query: Interactive Dashboard with All Categories -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Create dashboard container
const dashboard = dv.el("div", "", {cls: "documentation-dashboard"});

// Add title
dv.el("h1", "üìö Repository Documentation Dashboard", {container: dashboard});

// Create tabs or sections
const categories = [
    {name: "All Files", filter: () => true},
    {name: "Monorepos", filter: (file) => file.repo_category === 'Monorepo'},
    {name: "Components", filter: (file) => file.repo_category.includes('Component')},
    {name: "Rust", filter: (file) => file.primary_languages.includes('Rust')},
    {name: "TypeScript", filter: (file) => file.primary_languages.includes('TypeScript')},
    {name: "README", filter: (file) => file.filename === 'README.md'},
    {name: "AGENTS", filter: (file) => file.filename === 'AGENTS.md'},
    {name: "CHANGELOG", filter: (file) => file.filename === 'CHANGELOG.md'}
];

// Create search input
const searchInput = dv.el("input", "", {
    type: "text",
    placeholder: "üîç Search repositories and files...",
    style: "width: 100%; padding: 12px; margin: 20px 0; border: 2px solid #e1e1e1; border-radius: 8px; font-size: 16px;",
    container: dashboard
});

// Create category buttons
const buttonContainer = dv.el("div", "", {
    style: "margin: 20px 0; display: flex; flex-wrap: wrap; gap: 10px;",
    container: dashboard
});

// Create results container
const resultsContainer = dv.el("div", "", {container: dashboard});

let currentFilter = categories[0].filter;

// Function to create category buttons
categories.forEach((category, index) => {
    const button = dv.el("button", category.name, {
        style: `padding: 8px 16px; border: 2px solid #007acc; background: ${index === 0 ? '#007acc' : 'transparent'}; color: ${index === 0 ? 'white' : '#007acc'}; border-radius: 20px; cursor: pointer; font-weight: bold;`,
        container: buttonContainer
    });
    
    button.addEventListener("click", () => {
        // Update button styles
        buttonContainer.querySelectorAll('button').forEach(btn => {
            btn.style.background = 'transparent';
            btn.style.color = '#007acc';
        });
        button.style.background = '#007acc';
        button.style.color = 'white';
        
        // Update filter and render
        currentFilter = category.filter;
        renderFilteredTable();
    });
});

// Function to render table based on current filter and search
function renderFilteredTable() {
    const searchTerm = searchInput.value.toLowerCase();
    
    let filteredFiles = jsonData.documentation_files.filter(currentFilter);
    
    if (searchTerm) {
        filteredFiles = filteredFiles.filter(file => 
            file.repo_name.toLowerCase().includes(searchTerm) ||
            file.filename.toLowerCase().includes(searchTerm) ||
            file.relative_path.toLowerCase().includes(searchTerm)
        );
    }
    
    resultsContainer.innerHTML = "";
    
    if (filteredFiles.length === 0) {
        dv.el("div", "üîç No files found matching your criteria.", {
            container: resultsContainer,
            style: "text-align: center; padding: 40px; color: #666; font-size: 18px;"
        });
        return;
    }
    
    // Sort by last modified (most recent first)
    filteredFiles.sort((a, b) => b.last_modified_timestamp - a.last_modified_timestamp);
    
    const tableData = filteredFiles.map(file => [
        `[[${file.filename}|${file.filename}]]`,
        `[[${file.repo_name}|${file.repo_name}]]`,
        file.relative_path,
        new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
    ]);
    
    dv.table(
        ["üìÑ File", "üìÅ Repository", "üõ§Ô∏è Path", "üìÖ Last Modified"],
        tableData,
        {container: resultsContainer}
    );
    
    // Add statistics
    dv.el("div", `üìä **${filteredFiles.length}** files found`, {
        container: resultsContainer,
        style: "margin-top: 15px; padding: 10px; background: #f0f8ff; border-left: 4px solid #007acc; font-weight: bold;"
    });
}

// Add search functionality
searchInput.addEventListener("input", renderFilteredTable);

// Initial render
renderFilteredTable();
```

## Repository Structure Tree

<!-- DataviewJS Query: Hierarchical Repository Tree with Document Counts -->
```dataviewjs
// Repository structure tree generator with document counts
// Groups repositories by category and displays document counts
// Implementation: Step 4 - Generate repository structure tree with counts
// Author: AI Agent (2025-01-27)
// Purpose: Creates hierarchical unordered list using dv.list() grouped by repo.category ‚Üí repo.name
// Features: Document counts (#docs: N), smart linking (README.md priority, fallback to Coverage.md or folder)

// Load repository inventory data
const fs = require('fs');
const inventoryPath = 'surrentumlabs_repo_inventory.json';
let repoInventory = {};

// Try to load repository inventory
try {
    const inventoryData = JSON.parse(fs.readFileSync(inventoryPath, 'utf8'));
    repoInventory = inventoryData;
} catch (error) {
    dv.paragraph(`‚ö†Ô∏è Could not load repository inventory from ${inventoryPath}`);
    return;
}

// Load documentation cache
const docsPath = '.scripts/cache/docs_index.json';
let docsData = {};

try {
    docsData = JSON.parse(fs.readFileSync(docsPath, 'utf8'));
} catch (error) {
    dv.paragraph(`‚ö†Ô∏è Could not load documentation cache from ${docsPath}`);
}

// Group repositories by category from inventory
const reposByCategory = {};
const docCounts = {};

// Process repository inventory
if (repoInventory.repositories) {
    repoInventory.repositories.forEach(repo => {
        // Determine category based on path structure
        let category = 'Other';
        if (repo.path.includes('Rust Component Repos')) {
            category = 'Rust Components';
        } else if (repo.path.includes('Typescript Component Repos')) {
            category = 'TypeScript Components';
        } else if (repo.path.includes('Monorepos')) {
            category = 'Monorepos';
        }
        
        if (!reposByCategory[category]) {
            reposByCategory[category] = [];
        }
        reposByCategory[category].push(repo);
        
        // Count documents for this repository
        docCounts[repo.name] = 0;
        if (docsData.documentation_files) {
            docCounts[repo.name] = docsData.documentation_files.filter(
                file => file.repo_name === repo.name
            ).length;
        }
    });
}

// Check for whiply_project documentation
let whiplyDocCount = 0;
if (docsData.documentation_files) {
    whiplyDocCount = docsData.documentation_files.filter(
        file => file.repo_name === 'whiply_project'
    ).length;
}

// Generate the hierarchical list structure
const listItems = [];

// Sort categories for consistent display
const categoryOrder = ['Monorepos', 'Rust Components', 'TypeScript Components', 'Other'];
const sortedCategories = Object.keys(reposByCategory).sort((a, b) => {
    const indexA = categoryOrder.indexOf(a);
    const indexB = categoryOrder.indexOf(b);
    if (indexA === -1 && indexB === -1) return a.localeCompare(b);
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
});

// Build category sections
sortedCategories.forEach(category => {
    const repos = reposByCategory[category];
    
    // Category header
    listItems.push(`**${category}**`);
    
    // Sort repositories alphabetically
    repos.sort((a, b) => a.name.localeCompare(b.name));
    
    repos.forEach(repo => {
        const count = docCounts[repo.name] || 0;
        const repoPath = `/home/cinder/Documents/repos/Repos Docs/${repo.name}`;
        
        // Check if README.md exists in Repos Docs
        let linkTarget = '';
        try {
            if (fs.existsSync(`${repoPath}/README.md`)) {
                linkTarget = `[[${repo.name}/README.md|${repo.name}]]`;
            } else if (fs.existsSync(`${repoPath}/Coverage.md`)) {
                linkTarget = `[[${repo.name}/Coverage.md|${repo.name}]]`;
            } else {
                linkTarget = `[[${repo.name}|${repo.name}]]`;
            }
        } catch (e) {
            linkTarget = repo.name;
        }
        
        listItems.push(`  - ${linkTarget} (#docs: ${count})`);
    });
    
    // Add spacing between categories
    listItems.push('');
});

// Add whiply_project if it has documentation
if (whiplyDocCount > 0) {
    listItems.push('**Additional Projects**');
    const whiplyPath = '/home/cinder/Documents/repos/Repos Docs/whiply_project';
    let whiplyLink = '';
    try {
        if (fs.existsSync(`${whiplyPath}/README.md`)) {
            whiplyLink = '[[whiply_project/README.md|whiply_project]]';
        } else if (fs.existsSync(`${whiplyPath}/Coverage.md`)) {
            whiplyLink = '[[whiply_project/Coverage.md|whiply_project]]';
        } else {
            whiplyLink = '[[whiply_project|whiply_project]]';
        }
    } catch (e) {
        whiplyLink = 'whiply_project';
    }
    
    listItems.push(`  - ${whiplyLink} (#docs: ${whiplyDocCount})`);
    listItems.push('');
}

// Display the structured list
dv.list(listItems);

// Summary statistics
const totalRepos = Object.values(reposByCategory).reduce((sum, repos) => sum + repos.length, 0);
const totalDocs = Object.values(docCounts).reduce((sum, count) => sum + count, 0) + whiplyDocCount;

dv.paragraph(`üìä **Summary:** ${totalRepos} repositories, ${totalDocs} documentation files`);
```

## Recently Modified Files

<!-- DataviewJS Query: 20 Most Recently Modified Files -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Sort by last modified timestamp (most recent first) and limit to 20
const recentFiles = jsonData.documentation_files
    .sort((a, b) => b.last_modified_timestamp - a.last_modified_timestamp)
    .slice(0, 20);

// Create table
const tableData = recentFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Showing the 20 most recently modified files**`);
```

## Documentation Categories

### Filter by Repository Type

#### Monorepo Documentation

<!-- DataviewJS Query: Monorepo Documentation -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Filter for Monorepo category
const monorepoFiles = jsonData.documentation_files.filter(file => 
    file.repo_category === 'Monorepo'
);

// Create table
const tableData = monorepoFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Total Monorepo files:** ${monorepoFiles.length}`);
```

#### Component Documentation

<!-- DataviewJS Query: Component Documentation -->  
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Filter for Component categories (TypeScript Component, Rust Component)
const componentFiles = jsonData.documentation_files.filter(file => 
    file.repo_category.includes('Component')
);

// Create table
const tableData = componentFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Total Component files:** ${componentFiles.length}`);
```

### Filter by Programming Language

#### Rust Documentation

<!-- DataviewJS Query: Rust Documentation -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Filter for Rust primary language
const rustFiles = jsonData.documentation_files.filter(file => 
    file.primary_languages.includes('Rust')
);

// Create table
const tableData = rustFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Total Rust files:** ${rustFiles.length}`);
```

#### TypeScript Documentation

<!-- DataviewJS Query: TypeScript Documentation -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Filter for TypeScript primary language
const tsFiles = jsonData.documentation_files.filter(file => 
    file.primary_languages.includes('TypeScript')
);

// Create table
const tableData = tsFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Total TypeScript files:** ${tsFiles.length}`);
```

## Document Type Categories

### README Files

<!-- DataviewJS Query: README Files -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Filter for README files
const readmeFiles = jsonData.documentation_files.filter(file => 
    file.filename === 'README.md'
);

// Create table
const tableData = readmeFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Total README files:** ${readmeFiles.length}`);
```

### AGENTS Files

<!-- DataviewJS Query: AGENTS Files -->
```dataviewjs
// Load JSON cache
const fs = require('fs');
const path = '.scripts/cache/docs_index.json';
const jsonData = JSON.parse(fs.readFileSync(path, 'utf8'));

// Filter for AGENTS files
const agentsFiles = jsonData.documentation_files.filter(file => 
    file.filename === 'AGENTS.md'
);

// Create table
const tableData = agentsFiles.map(file => [
    `[[${file.filename}|${file.filename}]]`,
    `[[${file.repo_name}|${file.repo_name}]]`,
    file.relative_path,
    new Date(file.last_modified_timestamp * 1000).toLocaleDateString()
]);

// Display table
dv.table(
    ["File", "Repo", "Path", "Last Modified"],
    tableData
);

dv.paragraph(`**Total AGENTS files:** ${agentsFiles.length}`);
```

---

## Technical Implementation

This documentation homepage leverages:

1. **Documentation Inventory Script** (`.scripts/inventory_docs.js`) - Scans Surrentumlabs repositories for documentation files
2. **JSON Cache** (`.scripts/cache/docs_index.json`) - Stores metadata about all documentation files  
3. **Repository Inventory** (`surrentumlabs_repo_inventory.json`) - Repository structure and categorization
4. **DataviewJS Queries** - Interactive filtering and display of documentation data

### Updating Documentation Index

To refresh the documentation index, run:

```bash
node .scripts/inventory_docs.js
```

This will regenerate the cache with current file timestamps and metadata.

### Features

- ‚úÖ Interactive dashboard with live filtering
- ‚úÖ Repository categorization (Monorepo vs Components)  
- ‚úÖ Language-based filtering (Rust, TypeScript, etc.)
- ‚úÖ Document type grouping (README, AGENTS, CHANGELOG)
- ‚úÖ Recently modified files tracking
- ‚úÖ Hierarchical repository tree with document counts
- ‚úÖ Obsidian-compatible file linking
- ‚úÖ Real-time search functionality

---

*Last updated: 2025-01-27 by AI Agent (Step 6: Finalize Markdown and commit)*
<!-- Code annotation: Created Documentation-Homepage.md with Obsidian DataviewJS queries per rule zb1YgK1oGzQCJ7qBVsLYBy -->
